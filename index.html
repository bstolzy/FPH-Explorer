<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <title>FPH Explorer Online Tool</title>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css"/>
  <style>
    html,body{height:100%;margin:0}
    #wrap{display:flex;flex-direction:column;height:100%}
    #top{padding:6px 10px;border-bottom:1px solid #ddd;font:14px system-ui,Arial}
    #maps{display:flex;flex:1;min-height:0}
    #map-wsa,#map-vol{flex:1}
    #sliderWrap{padding:6px 10px;border-top:1px solid #ddd;font:12px system-ui}
    #ts{width:100%}
    .label{font-weight:600;margin-right:8px}
    .legend{display:inline-flex;gap:6px;align-items:center;margin-left:10px}
    .swatch{width:14px;height:14px;border:1px solid #888}
  </style>
</head>
<body>
<div id="wrap">
  <div id="top">
    <span class="label">Basemap:</span>
    <select id="basemap">
      <option value="osm" selected>OpenStreetMap</option>
      <option value="esri">Satellite (Esri)</option>
    </select>
    <span class="legend">
      <span>Low</span>
      <span class="swatch" id="sw0"></span>
      <span class="swatch" id="sw1"></span>
      <span class="swatch" id="sw2"></span>
      <span class="swatch" id="sw3"></span>
      <span class="swatch" id="sw4"></span>
      <span>High</span>
    </span>
  </div>

  <div id="maps">
    <div id="map-wsa" title="Water Surface Area"></div>
    <div id="map-vol" title="Volume (ML)"></div>
  </div>

  <div id="sliderWrap">
    <span class="label">Time:</span>
    <input type="range" id="ts" min="0" max="0" value="0" step="1"/>
    <span id="tsLabel"></span>
  </div>
</div>

<script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
<script src="https://unpkg.com/papaparse@5.3.2/papaparse.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>

<script>
/* -------------------- Config & helpers -------------------- */
const DATA = {
  polys: encodeURI('data/geeid_all_wb_1796.geojson'),
  catchments: encodeURI('data/Catchment boundaries for aggregation.geojson'),
  csvs: [
    'data/per_obs_depth_Barwon-Darling.csv',
    'data/per_obs_depth_Border Rivers.csv',
    'data/per_obs_depth_CB other.csv',
    'data/per_obs_depth_Condamine-Balonne.csv',
    'data/per_obs_depth_Gwydir.csv',
    'data/per_obs_depth_Lower Namoi.csv',
    'data/per_obs_depth_Macquarie.csv',
    'data/per_obs_depth_Upper Namoi.csv'
  ].map(encodeURI)
};

// Map raw -> display catchment name
function displayCatchmentName(raw) {
  const t = (raw||'').trim();
  if (t === 'CB other' || t === 'CB Other') return 'Condamine-Balonne Other';
  if (t === 'Condamine-Balonne') return 'Condamine-Balonne Lower';
  return t; // others already correct
}

// colour ramp (5 classes)
function ramp(val, min, max) {
  if (!isFinite(val)) return '#cccccc';
  const t = (val - min) / (max - min || 1); // 0..1
  // simple 5-class HSL blue→red
  const bins = [0.1, 0.3, 0.5, 0.7];
  const colors = ['#edf8fb','#b2e2e2','#66c2a4','#2ca25f','#006d2c']; // ColorBrewer-ish
  const idx = t < bins[0] ? 0 : t < bins[1] ? 1 : t < bins[2] ? 2 : t < bins[3] ? 3 : 4;
  return colors[idx];
}
['#edf8fb','#b2e2e2','#66c2a4','#2ca25f','#006d2c']
  .forEach((c,i)=>document.getElementById('sw'+i).style.background=c);

/* -------------------- Basemaps & maps -------------------- */
const osm = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',{attribution:'© OpenStreetMap'});
const esri = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}',{attribution:'Tiles © Esri'});

const center = [-28,148], zoom = 6;
const mapWSA = L.map('map-wsa', { center, zoom, layers:[osm] });
const mapVOL = L.map('map-vol', { center, zoom, layers:[osm] });

document.getElementById('basemap').addEventListener('change', e=>{
  const layer = e.target.value === 'esri' ? esri : osm;
  [mapWSA,mapVOL].forEach(m=>{
    m.eachLayer(l=>{ if (l instanceof L.TileLayer) m.removeLayer(l); });
    layer.addTo(m);
  });
});

// keep maps roughly in sync
mapWSA.on('move', ()=> mapVOL.setView(mapWSA.getCenter(), mapWSA.getZoom(), {animate:false}));
mapVOL.on('move', ()=> mapWSA.setView(mapVOL.getCenter(), mapVOL.getZoom(), {animate:false}));

/* -------------------- Data holders -------------------- */
let polyLayerWSA, polyLayerVOL, catchLayerWSA, catchLayerVOL;
const idxByGEEID = new Map();     // GEEID -> array index lookup
const seriesByPoly = new Map();   // GEEID -> [{t, wsa_m2, vol_ML}]
const seriesByCatch = new Map();  // displayCatch -> [{t, wsa_m2, vol_ML}]
let timestamps = [];              // sorted unique Date objects
let tsIndex = 0;

/* -------------------- Load GeoJSONs -------------------- */
Promise.all([
  fetch(DATA.polys).then(r=>r.json()),
  fetch(DATA.catchments).then(r=>r.json()),
  loadAllCsvs()
]).then(([polys, catches])=>{
  // polygons
  const baseStyle = { color:'#0033cc', weight:1, fillOpacity:0.25 };
  polyLayerWSA = L.geoJSON(polys, {
    style: f => baseStyle,
    onEachFeature: (f, layer)=> bindPolyEvents(f, layer, 'WSA')
  }).addTo(mapWSA);

  polyLayerVOL = L.geoJSON(polys, {
    style: f => baseStyle,
    onEachFeature: (f, layer)=> bindPolyEvents(f, layer, 'VOL')
  }).addTo(mapVOL);

  try {
    const b = polyLayerWSA.getBounds();
    mapWSA.fitBounds(b); mapVOL.fitBounds(b);
  } catch(e){}

  // catchments (lighter)
  const cStyle = { color:'#666', weight:2, fillOpacity:0.05 };
  catchLayerWSA = L.geoJSON(catches, {
    style: cStyle,
    onEachFeature: (f, layer)=> bindCatchEvents(f, layer, 'WSA')
  }).addTo(mapWSA);

  catchLayerVOL = L.geoJSON(catches, {
    style: cStyle,
    onEachFeature: (f, layer)=> bindCatchEvents(f, layer, 'VOL')
  }).addTo(mapVOL);

  // initial paint
  paintForTimeIndex(0);
});

/* -------------------- CSV loading & indexing -------------------- */
function loadAllCsvs(){
  return new Promise((resolve)=>{
    const all = [];
    let done = 0;
    DATA.csvs.forEach(path=>{
      Papa.parse(path, {
        download:true, header:true, dynamicTyping:true, skipEmptyLines:true,
        complete: res => {
          all.push(...res.data);
          done++;
          if (done === DATA.csvs.length) {
            indexRows(all);
            resolve();
          }
        },
        error: err => { console.error('CSV error', path, err); done++; }
      });
    });
  });
}

function indexRows(rows){
  // expected columns: Timestamp,GEEID,Catchment,WSA_m2, Predicted_Volume_ML (plus others)
  // 1) normalize timestamps
  const tset = new Set();
  rows.forEach(r=>{
    const t = new Date(r.Timestamp);
    if (!isNaN(+t)) {
      r._t = t;
      tset.add(t.toISOString());
    }
    r._catchDisp = displayCatchmentName(r.Catchment);
  });
  timestamps = Array.from(tset).sort().map(s=>new Date(s));

  // 2) per-poly series
  rows.forEach(r=>{
    const id = String(r.GEEID);
    if (!seriesByPoly.has(id)) seriesByPoly.set(id, []);
    seriesByPoly.get(id).push({
      t: r._t,
      wsa_m2: Number(r.WSA_m2) || 0,
      vol_ML: Number(r.Predicted_Volume_ML) || 0
    });
  });
  // sort each series by time
  seriesByPoly.forEach(arr=>arr.sort((a,b)=>a.t-b.t));

  // 3) per-catchment aggregated series (sum by time)
  const byCatchByIso = new Map(); // catch -> iso -> {wsa,vol}
  rows.forEach(r=>{
    const c = r._catchDisp; const iso = r._t?.toISOString();
    if (!iso) return;
    if (!byCatchByIso.has(c)) byCatchByIso.set(c, new Map());
    const m = byCatchByIso.get(c);
    const o = m.get(iso) || {wsa:0, vol:0};
    o.wsa += Number(r.WSA_m2) || 0;
    o.vol += Number(r.Predicted_Volume_ML) || 0;
    m.set(iso, o);
  });
  byCatchByIso.forEach((m, c)=>{
    const arr = [];
    Array.from(m.keys()).sort().forEach(iso=>{
      const o = m.get(iso);
      arr.push({t:new Date(iso), wsa_m2:o.wsa, vol_ML:o.vol});
    });
    seriesByCatch.set(c, arr);
  });

  // slider init
  const slider = document.getElementById('ts');
  slider.max = Math.max(0, timestamps.length-1);
  slider.value = 0;
  slider.oninput = e=> paintForTimeIndex(Number(e.target.value));
}

/* -------------------- Painting by time -------------------- */
function paintForTimeIndex(i){
  tsIndex = Math.max(0, Math.min(i, timestamps.length-1));
  const t = timestamps[tsIndex];
  document.getElementById('tsLabel').textContent = t ? t.toISOString().slice(0,10) : '';

  // compute value ranges for this date for both metrics
  const valsWSA = [], valsVOL = [];
  seriesByPoly.forEach(arr=>{
    const pt = binaryFindByTime(arr, t);
    if (pt){ valsWSA.push(pt.wsa_m2); valsVOL.push(pt.vol_ML); }
  });
  const wMin = Math.min(...valsWSA, 0), wMax = Math.max(...valsWSA, 1);
  const vMin = Math.min(...valsVOL, 0), vMax = Math.max(...valsVOL, 1);

  function styleFor(f, metric){
    const id = String(f.properties.GEEID ?? f.properties.__poly_id__ ?? '');
    const ser = seriesByPoly.get(id);
    let val = NaN;
    if (ser){
      const pt = binaryFindByTime(ser, t);
      val = pt ? (metric==='WSA' ? pt.wsa_m2 : pt.vol_ML) : NaN;
    }
    const color = metric==='WSA' ? ramp(val, wMin, wMax) : ramp(val, vMin, vMax);
    return { color:'#333', weight:1, fill:true, fillOpacity:0.7, fillColor:color };
  }

  polyLayerWSA.setStyle(f=>styleFor(f,'WSA'));
  polyLayerVOL.setStyle(f=>styleFor(f,'VOL'));
}

// fast lookup for time (assumes arr sorted by t)
function binaryFindByTime(arr, t){
  if (!t || !arr || !arr.length) return null;
  const iso = t.toISOString();
  // exact match preferred; otherwise nearest previous
  let lo=0, hi=arr.length-1, best=null;
  while (lo<=hi){
    const mid=(lo+hi)>>1;
    const mt = arr[mid].t;
    if (mt.toISOString() === iso) return arr[mid];
    if (mt < t){ best = arr[mid]; lo = mid+1; } else { hi = mid-1; }
  }
  return best;
}

/* -------------------- Popups & charts -------------------- */
function bindPolyEvents(feature, layer, metric){
  const id = String(feature.properties.GEEID ?? feature.properties.__poly_id__ ?? '');
  const name = `GEEID ${id}`;
  layer.on('click', ()=>{
    const ser = seriesByPoly.get(id) || [];
    openChartPopup(layer, name, ser, metric);
  });
}

function bindCatchEvents(feature, layer, metric){
  // assume catchment name is in a property; fall back to 'name'/'Catchment'
  const raw = feature.properties?.name || feature.properties?.Catchment || '';
  const disp = displayCatchmentName(raw);
  layer.on('mouseover', ()=>{
    const ser = seriesByCatch.get(disp) || [];
    openChartPopup(layer, disp + ' (aggregated)', ser, metric);
  });
  layer.on('mouseout', ()=> layer.closePopup());
}

function openChartPopup(layer, title, ser, metric){
  const labels = ser.map(p=>p.t.toISOString().slice(0,10));
  const data = ser.map(p=> metric==='WSA' ? p.wsa_m2 : p.vol_ML);
  const unit = metric==='WSA' ? 'm²' : 'ML';

  const div = document.createElement('div');
  div.style.width = '320px';
  div.innerHTML = `<div style="font:600 13px system-ui;margin-bottom:6px">${title}<br/><span style="font-weight:400">Metric: ${metric} (${unit})</span></div><canvas id="c"></canvas>`;
  layer.bindPopup(div, {maxWidth: 360}).openPopup();

  // defer so canvas is in DOM
  setTimeout(()=>{
    new Chart(div.querySelector('#c').getContext('2d'), {
      type:'line',
      data:{ labels, datasets:[{ label: metric, data, pointRadius:0, tension:0.2 }]},
      options:{
        responsive:true,
        maintainAspectRatio:false,
        scales:{ x:{ ticks:{maxTicksLimit:6} }, y:{ beginAtZero:true } },
        plugins:{ legend:{display:false}, tooltip:{callbacks:{label:(ctx)=>`${ctx.parsed.y.toLocaleString()} ${unit}`}}}
      }
    });
  },0);
}
</script>
</body>
</html>
